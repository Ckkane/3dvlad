
'use strict';

import CSG from "./js/three-csg.js";

/* __V3D_TEMPLATE__ - template-based file; delete this line to prevent this file from being updated */


window.addEventListener('load', function() {

var CONTAINER_ID = 'v3d-container';

// video recording
var capturer1 = new CCapture( { format: 'webm', framerate: 15, name: "video", quality: 100} );
function render() {
    requestAnimationFrame(render);
    // rendering stuff ...

    capturer1.capture( document.querySelector('canvas.v3d-canvas') );
}
// video recording

(function() {

    var params = v3d.AppUtils.getPageParams();

    var PUZZLES_DIR = '/puzzles/';
    var logicURL = params.logic ? params.logic : '__LOGIC__visual_logic.js'.replace('__LOGIC__', '');
    var sceneURL = params.load ? params.load : '__URL__Evraz_Steel_Box.gltf'.replace('__URL__', '');
    if (!sceneURL) {
        console.log('No scene URL specified');
        return;
    }

    // some puzzles can benefit from cache
    v3d.Cache.enabled = true;

    if (v3d.AppUtils.isXML(logicURL)) {
        var logicURLJS = logicURL.match(/(.*)\.xml$/)[1] + '.js?v=20240625';
        new v3d.PuzzlesLoader().loadEditorWithLogic(PUZZLES_DIR, logicURLJS,
            function() {
                var initOptions = v3d.PL ? v3d.PL.execInitPuzzles({
                        container: CONTAINER_ID }).initOptions
                        : { useFullscreen: true };
                var appInstance = loadScene(sceneURL, initOptions);
                v3d.PE.viewportUseAppInstance(appInstance);
            }
        );
    } else if (v3d.AppUtils.isJS(logicURL)) {
        new v3d.PuzzlesLoader().loadLogic(logicURL + '?v=20240625', function() {
            var initOptions = v3d.PL ? v3d.PL.execInitPuzzles({
                    container: CONTAINER_ID }).initOptions
                    : { useFullscreen: true };
            loadScene(sceneURL, initOptions);
        });
    } else {
        loadScene(sceneURL, { useFullscreen: true });
    }
})();

function loadScene(sceneURL, initOptions) {

    initOptions = initOptions || {};

    var ctxSettings = {};
    if (initOptions.useBkgTransp) ctxSettings.alpha = true;
    if (initOptions.preserveDrawBuf) ctxSettings.preserveDrawingBuffer = true;

    var preloader = initOptions.useCustomPreloader
            ? createCustomPreloader(initOptions.preloaderProgressCb,
            initOptions.preloaderEndCb)
            : new v3d.SimplePreloader({ container: CONTAINER_ID });

    if (v3d.PE) {
        puzzlesEditorPreparePreloader(preloader);
    }

    var app = new v3d.App(CONTAINER_ID, ctxSettings, preloader);
    if (initOptions.useBkgTransp) {
        app.clearBkgOnLoad = true;
        app.renderer.setClearColor(0x000000, 0);
    }

    // namespace for communicating with code generated by Puzzles
    app.ExternalInterface = {};
    prepareExternalInterface(app);

    if (initOptions.preloaderStartCb) initOptions.preloaderStartCb();
    if (initOptions.useFullscreen) {
        initFullScreen();
    } else {
        var fsButton = document.getElementById('fullscreen_button');
        if (fsButton) fsButton.style.display = 'none';
    }

    sceneURL = initOptions.useCompAssets ? sceneURL + '.xz' : sceneURL;
    app.loadScene(sceneURL, function() {
        app.enableControls();
        app.run();

        if (v3d.PE) v3d.PE.updateAppInstance(app);
        if (v3d.PL) v3d.PL.init(app, initOptions);

        runCode(app);
    }, null, function() {
        console.log('Can\'t load the scene ' + sceneURL);
    });

    return app;
}

function createCustomPreloader(updateCb, finishCb) {
    function CustomPreloader() {
        v3d.Preloader.call(this);
    }

    CustomPreloader.prototype = Object.assign(Object.create(v3d.Preloader.prototype), {
        onUpdate: function(percentage) {
            v3d.Preloader.prototype.onUpdate.call(this, percentage);
            if (updateCb) updateCb(percentage);
        },
        onFinish: function() {
            v3d.Preloader.prototype.onFinish.call(this);
            if (finishCb) finishCb();
        }
    });

    return new CustomPreloader();
}

/**
 * Modify the app's preloader to track the loading process in the Puzzles Editor.
 */
function puzzlesEditorPreparePreloader(preloader) {
    // backward compatibility for loading new projects within the old Puzzles Editor
    if (v3d.PE.loadingUpdateCb !== undefined && v3d.PE.loadingFinishCb !== undefined) {
        var _onUpdate = preloader.onUpdate.bind(preloader);
        preloader.onUpdate = function(percentage) {
            _onUpdate(percentage);
            v3d.PE.loadingUpdateCb(percentage);
        }

        var _onFinish = preloader.onFinish.bind(preloader);
        preloader.onFinish = function() {
            _onFinish();
            v3d.PE.loadingFinishCb();
        }
    }
}

function initFullScreen() {

    var fsButton = document.getElementById('fullscreen_button');
    if (!fsButton) return;

    var container = document.getElementById(CONTAINER_ID);

    if (document.fullscreenEnabled ||
            document.webkitFullscreenEnabled ||
            document.mozFullScreenEnabled ||
            document.msFullscreenEnabled)
        fsButton.style.display = 'inline';

    fsButton.addEventListener('click', function(event) {
        event.stopPropagation();
        if (document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.mozFullScreenElement ||
                document.msFullscreenElement) {
            exitFullscreen();
        } else
            requestFullscreen(container);
    });

    function changeFullscreen() {
        if (document.fullscreenElement ||
                document.webkitFullscreenElement ||
                document.mozFullScreenElement ||
                document.msFullscreenElement) {
            fsButton.classList.remove('fullscreen-open');
            fsButton.classList.add('fullscreen-close');
        } else {
            fsButton.classList.remove('fullscreen-close');
            fsButton.classList.add('fullscreen-open');
        }
    }

    document.addEventListener('webkitfullscreenchange', changeFullscreen);
    document.addEventListener('mozfullscreenchange', changeFullscreen);
    document.addEventListener('msfullscreenchange', changeFullscreen);
    document.addEventListener('fullscreenchange', changeFullscreen);

    function requestFullscreen(elem) {
        if (elem.requestFullscreen)
            elem.requestFullscreen();
        else if (elem.mozRequestFullScreen)
            elem.mozRequestFullScreen();
        else if (elem.webkitRequestFullscreen)
            elem.webkitRequestFullscreen();
        else if (elem.msRequestFullscreen)
            elem.msRequestFullscreen();
    }

    function exitFullscreen() {
        if (document.exitFullscreen)
            document.exitFullscreen();
        else if (document.mozCancelFullScreen)
            document.mozCancelFullScreen();
        else if (document.webkitExitFullscreen)
            document.webkitExitFullscreen();
        else if (document.msExitFullscreen)
            document.msExitFullscreen();
    }
}

function prepareExternalInterface(app) {
    // register functions in the app.ExternalInterface to call them from Puzzles, e.g:
    // app.ExternalInterface.myJSFunction = function() {
    //     console.log('Hello, World!');
    // }

    app.ExternalInterface.renameObj = function(oldName,newName) {
        app.scene.getObjectByName(oldName).name = newName;
        //console.log(app.scene.getObjectByName(newName));         
    }


    app.ExternalInterface.getObject = function(x) {
        return app.scene.getObjectByName(x);  
    }


    app.ExternalInterface.getChildrenNames = function(x) {
        var childrenNames = [];
        if (app.scene.getObjectByName(x) === undefined) return [];
        else {
            app.scene.getObjectByName(x).children.forEach((element,index) => {
                childrenNames.push(app.scene.getObjectByName(x).children[index].name);
            });
            return childrenNames;  
        }

    }

    app.ExternalInterface.getParentName = function(x) {
        var parent = app.scene.getObjectByName(x).parent.name;
        return parent;
    }


    app.ExternalInterface.setCustomProp = function(x,key,value) {
        app.scene.getObjectByName(x).userData.v3d.customProps[key] = value;
    }

    app.ExternalInterface.setObjectProp = function(x,key,value) {
        app.scene.getObjectByName(x)[key] = value;
        // console.log('key = '+key + '; value = ' + value +'; added prop ?');
        // console.log(app.scene.getObjectByName(x));
    }

    app.ExternalInterface.getObjectProp = function(x,key) {
        return app.scene.getObjectByName(x)[`${key}`];
    }


    app.ExternalInterface.disableInteraction = function() {
        parent.document.getElementById('wait_overlay').style.zIndex = "999";
        //parent.document.getElementById('wait_overlay').focus();
        parent.document.body.style.cursor = "wait";
        document.body.style.cursor = "wait";
        //console.log('disable interaction complete');
    }


    app.ExternalInterface.enableInteraction = function() {
        parent.document.getElementById('wait_overlay').style.zIndex = "-2";
        parent.document.body.style.cursor = "default";
        document.body.style.cursor = "default";
        //console.log('enable interaction complete');
    }


    app.ExternalInterface.dispatchHeightInput = function(x) {
        parent.document.getElementById('height_input').value = x;
        parent.document.getElementById('height_input').dispatchEvent(new Event('input'));
    }


    app.ExternalInterface.dispatchWidthInput = function(x) {
        //console.log('x = ' + x);
        parent.document.getElementById('width_input').value = x;
        parent.document.getElementById('width_input').dispatchEvent(new Event('input'));
    }


    app.ExternalInterface.dispatchLengthInput = function(x) {
        parent.document.getElementById('length_input').value = x;
        parent.document.getElementById('length_input').dispatchEvent(new Event('input'));
    }


    app.ExternalInterface.cloneMaterial = function(x,x1,i) { 
        // x - material to copy object Name
        // x1 - new material name
        //i - object to assign newmat
        var newmat = app.scene.getObjectByName(x).material.clone();
        newmat.name = x1;
        //console.log(newmat);
        app.scene.getObjectByName(i).material = newmat;
    }


    app.ExternalInterface.createInstanceOfBodyPanels = function(x,x1,color_selected,selected_panel) {
        //x - objects List
        //x1 - objects count

        // console.log('obj list ='); console.log(x);
        // console.log('color_selected = ' + color_selected);
        // console.log('selected panel = ' + selected_panel);

        if (x1 == 0) { // no mesh. create empty instance to parent additional spacers
            console.log('no mesh. create empty instance to parent additional spacers');
            var inst = app.scene.getObjectByName('fromLeftBindPoint').clone(); //clone point
            inst.name = 'SPanels_Body_Instance';
            app.scene.add(inst);
            console.log(inst);
        }

        else { //create instance . white instances.

            var mesh = app.scene.getObjectByName(x[0]);
            console.log(mesh);

            //create material
            var material = new THREE.MeshStandardMaterial();
            //var color = new THREE.Color("rgb(31%, 32%, 29%)");
            var color = new THREE.Color(color_selected);

            material.name = "SPanelsBodyMaterial";
            material.metalness = 0.5;
            material.roughness = 0.6;
            ///console.log(app.scene.getObjectByName('sp_stenovaya_flat_1000mm').material);
            //material.clippingPlanes = app.scene.getObjectByName('sp_stenovaya_flat_1000mm').material.clippingPlanes;
            material.clippingPlanes = app.scene.getObjectByName('sp_stenovaya_vee_rib_200_1000mm').material.clippingPlanes;
            
            mesh.material = material;

            const instancedMesh = new THREE.InstancedMesh(mesh.geometry, mesh.material, x1);

            var objList = x;
            // console.log(' ---- objList = ');
            // console.log(objList);

            var eachSidePanels = [[],[],[],[]]; // [A, B, C , D]

            for ( let i = 0; i < x1; i ++ ) {
                    //create list of panels for each side
                    if (objList[i].indexOf('_A-') !== -1 ) eachSidePanels[0].push(objList[i]);
                    else if (objList[i].indexOf('_B-') !== -1 ) eachSidePanels[1].push(objList[i]);
                    else if (objList[i].indexOf('_C-') !== -1 ) eachSidePanels[2].push(objList[i]);
                    else if (objList[i].indexOf('_D-') !== -1 ) eachSidePanels[3].push(objList[i]);

                    //set matrix
                    var matrix = app.scene.getObjectByName(objList[i]).matrix;
                    instancedMesh.setMatrixAt(i, matrix);

                    //set color for each InstanceId
                    instancedMesh.setColorAt(i, color);
            }
            
            instancedMesh.name = 'SPanels_Body_Instance';
            app.scene.add(instancedMesh);
            console.log(app.scene.getObjectByName('SPanels_Body_Instance'));

            // console.log('each side panels =');
            // console.log(eachSidePanels);

            //white instance
            // 4 instances - for each side
            //console.log(app.scene.getObjectByName('SPanels_Body_Instance_White_A'));
                    if (app.scene.getObjectByName('SPanels_Body_Instance_White_A') !== undefined) { //remove white instance (4)
                        //console.log('-- remove SPanels_Body_Instances White');
                        app.scene.getObjectByName('SPanels_Body_Instance_White_A').geometry.dispose();
                        app.scene.remove(app.scene.getObjectByName('SPanels_Body_Instance_White_A'));
                        app.scene.getObjectByName('SPanels_Body_Instance_White_B').geometry.dispose();
                        app.scene.remove(app.scene.getObjectByName('SPanels_Body_Instance_White_B'));
                        app.scene.getObjectByName('SPanels_Body_Instance_White_C').geometry.dispose();
                        app.scene.remove(app.scene.getObjectByName('SPanels_Body_Instance_White_C'));
                        app.scene.getObjectByName('SPanels_Body_Instance_White_D').geometry.dispose();
                        app.scene.remove(app.scene.getObjectByName('SPanels_Body_Instance_White_D'));
                    }


                    // create white color, and set color for each item in instance
                    var whiteColor = new THREE.Color("rgb(100%, 100%, 100%)");

                    //set white_mesh for 4 inst

                    //&& selected_panel.indexOf('vertical') === -1
                    if (selected_panel.indexOf('1000mm') !== -1) { // 1000 panel height horiz
                        var mesh_white = app.scene.getObjectByName('sp_stenovaya_vee_rib_200_1000mm_white').clone();
                    }
                    else if (selected_panel.indexOf('1200mm') !== -1) { // 1200
                        var mesh_white = app.scene.getObjectByName('sp_stenovaya_vee_rib_200_1200mm_white').clone();
                    }
                    else if (selected_panel.indexOf('1190mm') !== -1) { // 1190
                        var mesh_white = app.scene.getObjectByName('sp_stenovaya_vee_rib_200_1190mm_white').clone();
                    }
                    else if (selected_panel.indexOf('profilirovanniy_list') !== -1) {
                        var mesh_white = app.scene.getObjectByName('sp_stenovaya_vee_rib_200_1000mm_white').clone();
                    }
                    // else if (selected_panel.indexOf('1000mm') !== -1 && selected_panel.indexOf('vertical') !== -1) {
                    //     console.log('vert 1000');
                    //     var mesh_white = app.scene.getObjectByName('vertical_sp_stenovaya_vee_rib_200_1000mm').clone();
                    // }
                    
                    //var mesh_white = app.scene.getObjectByName('sp_stenovaya_vee_rib_200_1000mm').clone();

                    mesh_white.name = "body_white_mesh";

                    mesh_white.material = app.scene.getObjectByName('sp_stenovaya_vee_rib_200_1000mm').children[0].material; //assign "white_material"
                    //mesh_white.material = material;
                    //console.log(mesh_white);

                    //create 4 instances - for each side
                    const instancedMesh_white_A = new THREE.InstancedMesh(mesh_white.geometry, mesh_white.material, eachSidePanels[0].length);
                    instancedMesh_white_A.name = "SPanels_Body_Instance_White_A";
                    if (eachSidePanels[0].length > 0) {
                        for ( let i = 0; i < eachSidePanels[0].length; i ++ ) {
                            var matrix = app.scene.getObjectByName(eachSidePanels[0][i]).matrix;
                            instancedMesh_white_A.setMatrixAt(i, matrix);
                            //set color for each InstanceId
                            instancedMesh_white_A.setColorAt(i, whiteColor);
                        }
                        instancedMesh_white_A.instanceColor.needsUpdate = true;
                    }
                    //console.log(instancedMesh_white_A);
                    instancedMesh_white_A.position.x = 0.074;
                    app.scene.add(instancedMesh_white_A);


                    const instancedMesh_white_B = new THREE.InstancedMesh(mesh_white.geometry, mesh_white.material, eachSidePanels[1].length);
                    if (eachSidePanels[1].length > 0) {
                        for ( let i = 0; i < eachSidePanels[1].length; i ++ ) {
                            var matrix = app.scene.getObjectByName(eachSidePanels[1][i]).matrix;
                            instancedMesh_white_B.setMatrixAt(i, matrix);
                            //set color for each InstanceId
                            instancedMesh_white_B.setColorAt(i, whiteColor);
                        }
                        instancedMesh_white_B.instanceColor.needsUpdate = true;
                    }
                    instancedMesh_white_B.position.z = - 0.074; 
                    instancedMesh_white_B.name = "SPanels_Body_Instance_White_B";
                    app.scene.add(instancedMesh_white_B);


                    const instancedMesh_white_C = new THREE.InstancedMesh(mesh_white.geometry, mesh_white.material, eachSidePanels[2].length);
                    if (eachSidePanels[2].length > 0) {
                        for ( let i = 0; i < eachSidePanels[2].length; i ++ ) {
                            var matrix = app.scene.getObjectByName(eachSidePanels[2][i]).matrix;
                            instancedMesh_white_C.setMatrixAt(i, matrix);
                            //set color for each InstanceId
                            instancedMesh_white_C.setColorAt(i, whiteColor);
                        }
                        instancedMesh_white_C.instanceColor.needsUpdate = true;
                    }
                    instancedMesh_white_C.position.x = - 0.074; 
                    instancedMesh_white_C.name = "SPanels_Body_Instance_White_C";
                    app.scene.add(instancedMesh_white_C);


                    const instancedMesh_white_D = new THREE.InstancedMesh(mesh_white.geometry, mesh_white.material, eachSidePanels[3].length);
                    if (eachSidePanels[3].length > 0) {
                        for ( let i = 0; i < eachSidePanels[3].length; i ++ ) {
                            var matrix = app.scene.getObjectByName(eachSidePanels[3][i]).matrix;
                            instancedMesh_white_D.setMatrixAt(i, matrix);
                            //set color for each InstanceId
                            instancedMesh_white_D.setColorAt(i, whiteColor);
                        }
                        instancedMesh_white_D.instanceColor.needsUpdate = true;
                    }
                    instancedMesh_white_D.position.z = 0.074; 
                    instancedMesh_white_D.name = "SPanels_Body_Instance_White_D";
                    app.scene.add(instancedMesh_white_D);

                    app.scene.remove(mesh_white); // remove cloned mesh


            //set instanceMaterial to initial mesh
            mesh.material = app.scene.getObjectByName(x[1]).material;
        }
    }






    app.ExternalInterface.createInstanceOfRoofPanels = function(x,x1,color_selected) {
        //x - objects List
        //x1 - objects count

        var mesh = app.scene.getObjectByName(x[0]);

        var material = new THREE.MeshStandardMaterial();
        //var color = new THREE.Color("rgb(31%, 32%, 29%)");
        var color = new THREE.Color(color_selected);

        material.name = "SPanelsRoofMaterial";
        material.metalness = 0.5;
        material.roughness = 0.6;

        // ao 
        var textureLoader = new THREE.TextureLoader();
        var aoMap = textureLoader.load('ao.jpg');
        material.aoMap = aoMap;
        material.aoMapIntensity = 0.4;

        material.clippingPlanes = [app.scene.getObjectByName('sp_stenovaya_vee_rib_200_1000mm').material.clippingPlanes[2]];

        mesh.material = material;
        //console.log(mesh.material);

        const instancedMesh = new THREE.InstancedMesh(mesh.geometry, mesh.material, x1);

        var objList = x;
        //console.log(objList);

        //create matrix and set color for each InstanceId
        for ( let i = 0; i < x1; i ++ ) {
            var matrix = app.scene.getObjectByName(objList[i]).matrix;
            instancedMesh.setMatrixAt(i, matrix);

            //set color for each InstanceId
             instancedMesh.setColorAt(i, color);
        }
         instancedMesh.instanceColor.needsUpdate = true;

        instancedMesh.name = 'SPanels_Roof_Instance';
        app.scene.add(instancedMesh);


        //white instance
                //remove current white roof instance
                if (app.scene.getObjectByName('SPanels_Roof_Instance_White') !== undefined) { //remove white instance
                    console.log('remove white roof last instance');
                    app.scene.remove(app.scene.getObjectByName('SPanels_Roof_Instance_White'));
                }

                // create white color, and set color for each item in instance
                var whiteColor = new THREE.Color("rgb(100%, 100%, 100%)");

                var mesh_white = app.scene.getObjectByName('sp_stenovaya_vee_rib_200_1000mm_white').clone();
                
                mesh_white.name = "roof_white_mesh";
                //console.log(mesh_white.scale);
                mesh_white.material = material;
                //console.log(mesh_white);
                const instancedMesh_white = new THREE.InstancedMesh(mesh_white.geometry, mesh_white.material, x1);
                //create matrix and set color for each InstanceId
                for ( let i = 0; i < x1; i ++ ) {
                    var matrix = app.scene.getObjectByName(objList[i]).matrix;
                    instancedMesh_white.setMatrixAt(i, matrix);

                    //set color for each InstanceId
                    instancedMesh_white.setColorAt(i, whiteColor);
                }
                instancedMesh_white.instanceColor.needsUpdate = true;

                instancedMesh_white.name = "SPanels_Roof_Instance_White";

                //instancedMesh_white.position.y = - 0.0001; // place down a litte. to see white instance
                app.scene.add(instancedMesh_white);

                //console.log(app.scene.getObjectByName('SPanels_Roof_Instance_White'));

 
        //console.log(app.scene.getObjectByName('SPanels_Roof_Instance'));

        app.scene.remove(mesh_white); // remove cloned mesh


        //set instanceMaterial to initial mesh
        mesh.material = app.scene.getObjectByName(x[1]).material;
    }


    app.ExternalInterface.setTransparentMaterialToObject = function(x) {
        console.log('setTransparentMaterialToObject');
        app.scene.getObjectByName(x).material.transparent = true;
        app.scene.getObjectByName(x).material.opacity = 0;
    }

    app.ExternalInterface.setColorBodyInstance = function(x) {
        app.scene.getObjectByName('window_hole').material.color.set("#"+x);
    }


    app.ExternalInterface.setColorAt = function(x,x1,color_selected) {
        //x- instance name
        //x1 - instanceId

        //console.log(color_selected);
        
        var instance = app.scene.getObjectByName(x);
        instance.setColorAt(x1, new THREE.Color(color_selected));
        instance.instanceColor.needsUpdate = true;
        //console.log(app.scene.getObjectByName(x));
    }


    app.ExternalInterface.subtractObjects = function(a,b) {
        //substract mesh b from mesh a
        // console.log(a);
        a = app.scene.getObjectByName(a);
        b = app.scene.getObjectByName(b);
        // console.log(a);
        // console.log(b);

        let meshA = a;
        let meshB = b; 

        meshA.updateMatrix();
        meshB.updateMatrix();

        //Create a bsp tree from each of the meshes
        let bspA = CSG.fromMesh( meshA )                        
        let bspB = CSG.fromMesh( meshB )
        
        // Subtract one bsp from the other via .subtract... other supported modes are .union and .intersect
        let bspResult = bspA.subtract(bspB);

        //console.log(bspResult);
        
        //Get the resulting mesh from the result bsp, and assign meshA.material to the resulting mesh
        let meshResult;
        meshResult = CSG.toMesh( bspResult, meshA.matrix, meshA.material );
        //console.log(meshResult);

        meshResult.name = a.name + "_temp";
        meshResult.groupNames = []; // need when append environment scene    (if not setted -> v3d legacy    error: undefined);
        meshResult.constraints = []; // need when append environment scene    (if not setted -> v3d legacy   error: undefined);

        app.scene.add(meshResult);
        //console.log(meshResult); 
    }

    

    app.ExternalInterface.uniteObjects = function(a,b) {
        
        a = app.scene.getObjectByName(a);
        b = app.scene.getObjectByName(b);
        //console.log(a);
        //console.log(b);

        let meshA = a;
        let meshB = b; 

        meshA.updateMatrix();
        meshB.updateMatrix();

        //Create a bsp tree from each of the meshes
        let bspA = CSG.fromMesh( meshA )                        
        let bspB = CSG.fromMesh( meshB )

        // Subtract one bsp from the other via .subtract... other supported modes are .union and .intersect
        let bspResult = bspA.union(bspB);
        
        //Get the resulting mesh from the result bsp, and assign meshA.material to the resulting mesh
        let meshResult = CSG.toMesh( bspResult, meshA.matrix, meshA.material );
        meshResult.name = a.name + "_temp"; 
        //let meshResult = CSG.toMesh( bspA, meshA.matrix, meshA.material );

        meshResult.groupNames = []; // need when append environment scene    (if not setted -> v3d legacy    error: undefined);
        meshResult.constraints = []; // need when append environment scene    (if not setted -> v3d legacy   error: undefined);
        
        app.scene.add(meshResult);
        console.log(meshResult);
    }


    app.ExternalInterface.createInstanceMaterial = function() {
        //console.log('createInstanceMaterial - External Interface function');

        var material = new THREE.MeshStandardMaterial();
        material.color = new THREE.Color("rgb(31%, 32%, 29%)");
        material.name = "instanceMaterial";
        material.metalness = 0.5;
        material.roughness = 0.6;
        //material.clippingPlanes = app.scene.getObjectByName('sp_stenovaya_flat_1000mm').material.clippingPlanes;
        material.clippingPlanes = app.scene.getObjectByName('sp_stenovaya_vee_rib_200_1000mm').material.clippingPlanes;
        

        // ao 
         var textureLoader = new THREE.TextureLoader();
         var aoMap = textureLoader.load('./ao.jpg');
         material.aoMap = aoMap;
         material.aoMapIntensity = 2;

        app.scene.getObjectByName('window_hole').material = material;
    }

    app.ExternalInterface.createColoringMaterial = function() {
        //console.log('createColoringMaterial - External Interface function');
        var material = new THREE.MeshStandardMaterial();
        material.color = new THREE.Color("rgb(15%, 0%, 20%)");
        material.name = "coloringMaterial";
        material.metalness = 0.5;
        material.roughness = 0.6;
    }


    app.ExternalInterface.getElementsByClassName = function(x) {
        var list1 = [];
        Array.from(parent.document.querySelectorAll('.'+x)).forEach(element => {
            list1.push(element.id);
        });
        return list1;
    }

    app.ExternalInterface.getSelectedItemIndex = function(x) {
        //x - id of select
        return parent.document.getElementById(x).selectedIndex;
    }

    app.ExternalInterface.getOptionValue = function(x) {
        //x - id of select 
        var selIndex = parent.document.getElementById(x).selectedIndex;
        return parent.document.getElementById(x).options[selIndex].value;
    }

    app.ExternalInterface.getFirstChildName = function(x) {
        //x - objectName
        //console.log('x = ' + x);
        //console.log(app.scene.getObjectByName(x));
        //console.log(app.scene.getObjectByName(x).children[0].name);
        return app.scene.getObjectByName(x).children[0].name;
    }

    app.ExternalInterface.getDataAttribute = function(x,x1) {
        //x - id, x1 - DataAttribute
        //console.log('x = '+x +'; x1 = '+x1+"; ");
        return parent.document.getElementById(x).dataset[`${x1}`];
    }

    app.ExternalInterface.getSelectedOptionId = function(x) {
        //x - id of select,
        //console.log(parent.document.getElementById(x).selectedOptions[0].id);
        return parent.document.getElementById(x).selectedOptions[0].id;
    }


    app.ExternalInterface.getHTMLProp = function(x,x1) {
        // x - id, x1 - property name
        //console.log(parent.document.getElementById(parent.document.getElementById(x)[`${x1}`]));
        return parent.document.getElementById(x)[`${x1}`];
    }

    app.ExternalInterface.setHTMLProp = function(x,key,val) {
        // x - id
        //console.log('setHTMLProp:          x = ' + x + '; key = ' + key +"; value = " + val);
        parent.document.getElementById(x)[`${key}`] = val;
        //console.log(parent.document.getElementById(x).key) 
    }

    app.ExternalInterface.disposeGeom = function(x) {
        if (app.scene.getObjectByName(x) !== undefined) { // only if there is such object on scene
            let object = app.scene.getObjectByName(x);
            //console.log(x);
            //console.log(object);
            if ( !object.type == "Mesh" ) {
                console.log(x + " Is Not A Mesh !");
                return
            }
            //console.log('dispose geometry! ' + x);
            object.geometry.dispose();
    
            //dispose material and texture
            if (object.material.isMaterial) {
                object.material.dispose();
    
                    // dispose textures
                    // for (const key of Object.keys(object.material)) {
                    //     const value = object.material[key]
                    //     if (value && typeof value === 'object' && 'minFilter' in value) {
                    //         console.log('dispose texture!')
                    //         value.dispose()
                    //     }
                    // }
            }
        }  
    }

    app.ExternalInterface.isObjectOnScene = function(x) {
        if (app.scene.getObjectByName(x) !== undefined) return true;
        else return false;
    }

    app.ExternalInterface.findAvailableAcrosser = async function(x) {
        //make array of all acrossers types
        var finded = null;

        //get list of all acrossers
        //var arr2 = Array.from(parent.document.querySelectorAll('#acrosser_select > label')).concat(Array.from(parent.document.querySelectorAll('#acrosser_select_2 > label')));
        var arr2 = Array.from(parent.document.querySelectorAll('#acrosser_select > label'));
        //console.log(arr2);
        //find first available acrosser and set it
        for (let i = 0; i < arr2.length; i++) { 
            if (arr2[i].classList.contains('disabled') === false && arr2[i].id != 'R4') {
                console.log(arr2[i].id + ' -> break!');
                finded = arr2[i].id;
                break; 
            } 
        }
        return finded;
    }

    app.ExternalInterface.parentPostMessage = function(x) {
        //console.log(x);
        parent.postMessage(x, '*');
    }

    app.ExternalInterface.createDashedLine = function() {
        //lets create 2 lines : 1 dashes, 2 - dots between dashes
        //for each line create material with parameters, points[] to set length of line (points = [startCoords, endCoords])

        //create dashes
        const material1 = new v3d.LineDashedMaterial({  color: 0x000000, dashSize: 0.5, gapSize: 0.5 });

        const points1 = [];
        points1.push(new v3d.Vector3(- 22, 0, 0)); // axes (x,z,y)
        points1.push(new v3d.Vector3(22, 0, 0));
    
        const geometry1 = new v3d.BufferGeometry().setFromPoints(points1);
        const line1 = new v3d.Line(geometry1, material1);
        line1.visible = false;
        line1.computeLineDistances();
        line1.name = "DashedLine1";
        app.scene.add(line1);


        //create dots
        // points2[start] = points1[start + 0.735] 
        const material2 = new v3d.LineDashedMaterial({  color: 0x000000, dashSize: 0.03, gapSize: 0.97 });

        const points2 = [];
        points2.push(new v3d.Vector3(- 21.265, 0, 0));
        points2.push(new v3d.Vector3(22, 0, 0));
    
        const geometry2 = new v3d.BufferGeometry().setFromPoints(points2);
        const line2 = new v3d.Line(geometry2, material2);
        line2.visible = false;
        line2.computeLineDistances();
        line2.name = "DashedLine2";
        app.scene.add(line2);
        console.log(app.scene.getObjectByName('DashedLine1'));
    }

    app.ExternalInterface.updateDashedLinePoints = function(line,length) {
        // console.log(" updateDashedLinePoints() - executed ");
        // console.log("line = " + line);
        //update dashes line

        var points = [];
        points.push(new v3d.Vector3( (-length/2) - 1, 0, 0 ));
        points.push(new v3d.Vector3( (length/2) + 1, 0, 0 ));
        app.scene.getObjectByName(line).geometry = new v3d.BufferGeometry().setFromPoints(points);
        app.scene.getObjectByName(line).computeLineDistances();

        //update dots line
        // console.log(line);
        line = line + "Dots";
        // console.log('line = ' + line);
        var points = [];
        points.push(new v3d.Vector3( (-length/2) - 1 + 0.735, 0, 0 ));
        points.push(new v3d.Vector3( (length/2) + 1, 0, 0 ));
        app.scene.getObjectByName(line).geometry = new v3d.BufferGeometry().setFromPoints(points);
        app.scene.getObjectByName(line).computeLineDistances();

    }


    app.ExternalInterface.checkMobile = function() {
        // console.log('check mobile = ' + (/Android|webOS|iPhone|iPad|iPod|BlackBerry|BB|PlayBook|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)));
        return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|BB|PlayBook|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent))
    }

    app.ExternalInterface.changeView = function(x) {
        parent.document.getElementById(x + 'View').click(); //light the button orange
        parent.document.getElementById(x + 'View').dispatchEvent(new PointerEvent('pointerup')); // change view
    }

    app.ExternalInterface.modelsList = function() {
        var modelsTemplates = [];
        var temp = 0;
        console.log('"modelList function" - models templates:....');
        // console.log(Array.from(parent.document.querySelectorAll(".select__block")));

        //commented to not thow error on mobile version on start
        // Array.from(parent.document.querySelectorAll(".select__block"))
        //         .forEach( (element)=> {
        //                 temp = temp + 1; // first 2 elements not needed
        //                 if (temp > 2) {
        //                     // console.log(element);
        //                     // console.log(element.children[0].options);
        //                     Array.from(element.children[0].options).forEach((el) => {
        //                         // console.log(el);
        //                         if (!modelsTemplates.includes(el.dataset.model)) {
        //                             modelsTemplates.push(el.dataset.model)
        //                         }
        //                     })
        //                 }
        //         })
        //commented to not thow error on mobile version on start

        //console.log(modelsTemplates);
        return modelsTemplates;
    }


    app.ExternalInterface.getObjectsByMaterial = function(x) {
        console.log('... searching for objects with "' + x + '" material...')
        //console.log(app.scene.children);
        app.scene.children.forEach((item)=> {
            if ( item.hasOwnProperty("material") && (item.material.name == "shaped_elements_material") ) {
                console.log(item.name)
            }
        })
    }


    app.ExternalInterface.goToSharedMode = function(x) {
        // x - pillar bases count  (to hide all "razmetka" objects)
        //console.log('*** goToSharedMode ***');
        parent.document.getElementById('toggleMainMenu_img').click(); // hide main menu
        // hide buttons
        parent.document.getElementById('toggleMainMenu_img').style.display = "none"; 
        parent.document.querySelector('.new_pro').style.display = "none";
        parent.document.querySelector('#saveVideo').style.display = "none";
        parent.document.querySelector('#export_gltf').style.display = "none";
        parent.document.querySelector('#screenshot').style.display = "none";
        // hide objects on scene
        app.scene.getObjectByName('trava').visible = false;
        app.scene.getObjectByName('kust_1').visible = false;
        app.scene.getObjectByName('kust_2').visible = false;
        app.scene.getObjectByName('scale_grid').visible = false;
        app.scene.getObjectByName('asphalt').visible = false;
        app.scene.getObjectByName('masshtab_composiciya').visible = false;
        app.scene.getObjectByName('fonarniy_stolb').visible = false;
        app.scene.getObjectByName('gorod').visible = false;
        app.scene.getObjectByName('scale_grid_XY').visible = false;
        for (let i = 2; i < (x+2); i++) {
            app.scene.getObjectByName("razmetka"+i).visible = false;
        }
    }

    app.ExternalInterface.isSharedMode = function() {
        if ( (parent.location.search.split("gtshmd").length - 1) === 1) { //found 'gtshmd' in location => go to shared mode
            return true;
        }
        else return false;
    }

    app.ExternalInterface.saveStart = function() {
        //console.log(capturer1);
        capturer1.start();
        //console.log('video capture starts');
        render()
    }

    app.ExternalInterface.saveStop = function() {
        console.log('stop video capturing');      
        capturer1.stop();
        // default save, will download automatically a file called {name}.extension (webm/gif/tar)
        capturer1.save();
    }

    app.ExternalInterface.assignMater = function(objSelector, matName) {
        // this function sets material to morphed object PROPERLY 

        var mat = v3d.SceneUtils.getMaterialByName(app, matName);
        //console.log(mat)
        var obj = app.scene.getObjectByName(objSelector);
        //console.log(obj);
        var firstSubmesh = obj.resolveMultiMaterial()[0];
        mat.morphTargets = true;        
        mat.morphNormals = true;
        mat.needsUpdate = true;
        firstSubmesh.material = mat;
    }

    app.ExternalInterface.truncateValue = function(x) {
        //x - element ID, y - min value, z - max value
        return Math.trunc(x);
    }

    app.ExternalInterface.getFortificationsList = function() {
        var fortificatiosList = [];
        app.scene.traverse(function(obj) {
            if (obj.name.includes("_fort")) {
                fortificatiosList.push(obj.name)
            }
        })
        return fortificatiosList;
    }
    
    
    app.ExternalInterface.setOptions_enabled_whenCoverBody = function(x) {
        //x = sheathing body type on scene
        console.log("*** ExtInt setOptions_enabled_whenCoverBody PROC ***")
        console.log(x)

        //conditions
        if (x[0] == "Сэндвич-панель" && x[3] == "Горизонтально" && parent.document.getElementById('SPanels_height_select').value == "1000") {
        //SP horizontal height 1000 => enable 980 windows and ribbon

            // enable single windows 980, and ribbons 980 
            [...Array.from(parent.document.getElementById('window_single_select').options),
            ...Array.from(parent.document.getElementById('window_ribbon_select').options)].forEach(el => {
                // if 980 enable , otherwise make hidden
                if (el.innerHTML.indexOf("980(h)") != -1) {
                    el.removeAttribute("hidden")
                    //make first 980(h) selected
                    if (el.parentNode.options[el.parentNode.selectedIndex].innerHTML.indexOf("980(h)") == -1) { //if selected not 980(h)
                        //make el selected (it is first appeared '980(h)')
                        el.parentNode.selectedIndex = el.index;
                    }           
                }
                else {
                    el.setAttribute("hidden", "")
                }
            })          
        }
        else if (x[0] == "Сэндвич-панель" && x[3] == "Горизонтально" && parent.document.getElementById('SPanels_height_select').value == "1190") {
        //SP horizontal height 1190 => enable 1170 windows and ribbon

            // enable single windows 1170, and ribbons 1170 
            [...Array.from(parent.document.getElementById('window_single_select').options),
            ...Array.from(parent.document.getElementById('window_ribbon_select').options)].forEach(el => {
                // if 1170 enable , otherwise make hidden
                if (el.innerHTML.indexOf("1170(h)") != -1) {
                    el.removeAttribute("hidden")
                    //make first 1170(h) selected
                    if (el.parentNode.options[el.parentNode.selectedIndex].innerHTML.indexOf("1170(h)") == -1) { //if selected not 1170(h)
                        //make el selected (it is first appeared '1170(h)')
                        el.parentNode.selectedIndex = el.index;
                    }           
                }
                else {
                    el.setAttribute("hidden", "")
                }
            })    
        }
        else if (x[0] == "Сэндвич-панель" && x[3] == "Вертикально") {
            // SP VERTICAL => enable only 1200
            [...Array.from(parent.document.getElementById('window_single_select').options),
            ...Array.from(parent.document.getElementById('window_ribbon_select').options)].forEach(el => {
                // if 1200 enable , otherwise make hidden
                if (el.innerHTML.indexOf("1200(h)") != -1) {
                    el.removeAttribute("hidden")
                    //make first 1200(h) selected
                    if (el.parentNode.options[el.parentNode.selectedIndex].innerHTML.indexOf("1200(h)") == -1) { //if selected not 1200(h)
                        //make el selected (it is first appeared '1200(h)')
                        el.parentNode.selectedIndex = el.index;
                    }           
                }
                else {
                    el.setAttribute("hidden", "")
                }
            })
        }
        else {
            //console.log("enable: all")
            Array.from(parent.document.getElementById('window_single_select').options).forEach(el => {            
                el.removeAttribute("hidden")
            })
            Array.from(parent.document.getElementById('window_ribbon_select').options).forEach(el => {            
                el.removeAttribute("hidden")
            })
        }
    }

    app.ExternalInterface.setOptionInSelect = function(innerHTML,selectIdCategory) {
        console.log('*** setOptionInSelect PROC ***')
        // console.log(selectIdCategory,innerHTML)
        // console.log(parent.document.querySelector(`select[data-category="${selectIdCategory}"]`))
        Array.from(parent.document.querySelector(`select[data-category="${selectIdCategory}"]`).options)
        .forEach((el)=>{
            if (el.innerHTML == innerHTML) { 
                console.log(`choose  - ${innerHTML} - in _ ${selectIdCategory} _ `)
                parent.document.querySelector(`select[data-category="${selectIdCategory}"]`).selectedIndex = el.index;
            }
        })
    }

    app.ExternalInterface.getWatermarkedScreenshot = async function(base64png) {
        var watermark = new Image();
        watermark.src = "./img/watermark.png";
        await watermark.decode();
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        var image = new Image();
        image.src = base64png;
        await image.decode();
        canvas.width = image.width;
        canvas.height = image.height;
        //draw screenshot
        ctx.drawImage(image, 0, 0);
        //set watermark size
        watermark.dataset.otstupSleva = canvas.width / 6.523;
        watermark.width = canvas.width - Number(watermark.dataset.otstupSleva) * 2;
        watermark.height = watermark.width / 12;
        watermark.dataset.otstupSverhu = (canvas.height - watermark.height) / 2;
        // draw watermark
        ctx.drawImage(watermark, Number(watermark.dataset.otstupSleva), Number(watermark.dataset.otstupSverhu), watermark.width, watermark.height);
        return canvas.toDataURL("image/jpeg");
    }

    app.ExternalInterface.makeRowSpacersTable = function() {
        let heightDiapasons = [3.6, 4.8, 6, 7.2, 8.4, 9.6, 10.8, 12];
        let widthDiapasons = [12, 15, 18, 21, 24];
        let spacersTable = {};
        // ********** рядовые ***********
        ["R4", "R1", "R2", "R41", "R5"].forEach((acrosser)=> {
            //console.log(acrosser)
            spacersTable[acrosser] = {};
            if (acrosser === "R4") { 
                heightDiapasons.forEach((height) => {
                    spacersTable[acrosser][height] = {};

                    if (height === 3.6) {
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [];
                            spacersTable[acrosser][height][width][1] = []; //length = 0
                        })
                    }
                    else if (height === 4.8) {
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            if ( (width !== 12) && (width !== 15) ) {
                                spacersTable[acrosser][height][width][0] = [4.26];
                                spacersTable[acrosser][height][width][1] = []; // length = 1
                            }
                            else spacersTable[acrosser][height][width][0] = [];
                            spacersTable[acrosser][height][width][1] = []; //length = 0
                        })
                    }
                    else if (height === 6) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26];
                            spacersTable[acrosser][height][width][1] = []; // length = 1
                        })
                    }
                    else if (height === 7.2) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26];
                            spacersTable[acrosser][height][width][1] = []; // length = 1
                        })
                    }
                    else if (height === 8.4) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26, 6.26];
                            spacersTable[acrosser][height][width][1] = [4.26]; // length = 2
                        })
                    }
                    else if ( height === 9.6) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26, 8.26];
                            spacersTable[acrosser][height][width][1] = [4.26]; // length = 2
                        })
                    }
                    else if ( height === 10.8) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26, 8.26];
                            spacersTable[acrosser][height][width][1] = [4.56]; // length = 2
                        })
                    }
                    else if ( height === 12) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26, 8.26];
                            spacersTable[acrosser][height][width][1] = [5.06]; // length = 2
                        })
                    }
                })
            }
            //======================================================
            if (acrosser === "R1") { 
                heightDiapasons.forEach((height) => {
                    spacersTable[acrosser][height] = {};

                    if (height === 3.6) {
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [];
                            spacersTable[acrosser][height][width][1] = []; //length = 0
                        })
                    }
                    else if (height === 4.8) {
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [];
                            spacersTable[acrosser][height][width][1] = []; //length = 0
                        })
                    }
                    else if (height === 6) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26];
                            spacersTable[acrosser][height][width][1] = []; // length = 1
                        })
                    }
                    else if (height === 7.2) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26];
                            spacersTable[acrosser][height][width][1] = []; // length = 1
                        })
                    }
                    else if (height === 8.4) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26];
                            spacersTable[acrosser][height][width][1] = [4.26]; // length = 1
                        })
                    }
                    else if (height === 9.6) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26, 6.26];
                            spacersTable[acrosser][height][width][1] = [4.26]; // length = 2
                        })
                    }
                    else if ( height === 10.8 ) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26, 8.26];
                            spacersTable[acrosser][height][width][1] = [4.56]; // length = 2
                        })
                    }
                    else if ( height === 12 ) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26, 8.26];
                            spacersTable[acrosser][height][width][1] = [5.06]; // length = 2
                        })
                    }
                })
            }
            //======================================================
            if (acrosser === "R2") { 
                heightDiapasons.forEach((height) => {
                    spacersTable[acrosser][height] = {};

                    if (height === 3.6) {
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [];
                            spacersTable[acrosser][height][width][1] = []; //length = 0
                        })
                    }
                    else if (height === 4.8) {
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26];
                            spacersTable[acrosser][height][width][1] = []; // length = 1
                        })
                    }
                    else if (height === 6) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26];
                            spacersTable[acrosser][height][width][1] = []; // length = 1
                        })
                    }
                    else if (height === 7.2) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26];
                            spacersTable[acrosser][height][width][1] = []; // length = 1
                        })
                    }
                    else if (height === 8.4) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26, 6.26];
                            spacersTable[acrosser][height][width][1] = [4.26]; // length = 2
                        })
                    }
                    else if ( height === 9.6 ) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26, 8.26];
                            spacersTable[acrosser][height][width][1] = [4.26]; // length = 2
                        })
                    }
                    else if ( height === 10.8 ) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26, 8.26];
                            spacersTable[acrosser][height][width][1] = [4.56]; // length = 2
                        })
                    }
                    else if ( height === 12 ) { 
                        widthDiapasons.forEach((width) => {
                            spacersTable[acrosser][height][width] = {};
                            spacersTable[acrosser][height][width][0] = [4.26, 8.26];
                            spacersTable[acrosser][height][width][1] = [5.06]; // length = 2
                        })
                    }
                })
            }
            //======================================================
            if (acrosser === "R41") { 
                //same data as R4 
                spacersTable[acrosser] = spacersTable['R4']
            }
            //======================================================
            if (acrosser === "R5") { 
                //same data as R1 
                spacersTable[acrosser] = spacersTable['R1']
            }
            

        })
        // ********** рядовые ***********
        return spacersTable;
    }


    app.ExternalInterface.makeFaceSpacersTable = function() {
        // ********** торцевые *********** одинаковая таблица для всех типов поперечников
        let acrossersList = ["R4", "R1", "R2", "R41", "R5"];
        let heightDiapasons = [3.6, 4.8, 6, 7.2, 8.4, 9.6, 10.8, 12];
        let widthDiapasons = [12, 15, 18, 21, 24];
        let spacersToretsTable = {};
        acrossersList.forEach((acrosser)=> {
            spacersToretsTable[acrosser] = {};
            heightDiapasons.forEach((height) => {
                spacersToretsTable[acrosser][height] = {};
                if (height === 3.6) {
                    widthDiapasons.forEach((width) => {
                        spacersToretsTable[acrosser][height][width] = []; //length = 0
                    })
                }
                
                else if ((height === 4.8 || height === 6 || height === 7.2 || height === 8.4) && !(height === 4.8 && acrosser === "R1")) {
                    widthDiapasons.forEach((width) => {
                        spacersToretsTable[acrosser][height][width] = [4.56]; // length = 1
                    })
                }
                else if (height === 4.8 && acrosser === "R1") {
                    widthDiapasons.forEach((width) => {
                        spacersToretsTable[acrosser][height][width] = []; //length = 0
                    })
                } 
                else if ( height === 9.6 || height === 10.8 || height === 12 ) { 
                    widthDiapasons.forEach((width) => {
                        spacersToretsTable[acrosser][height][width] = [4.56, 8.26]; // length = 2
                    })
                }
            })
        })
        console.log(spacersToretsTable)
        return spacersToretsTable;
        // ********** торцевые *********** одинаковая таблица для всех типов поперечников
    }
}








function runCode(app) {
    // add your code here, e.g. console.log('Hello, World!');

    app.ExternalInterface.createColoringMaterial();



}


 

});
